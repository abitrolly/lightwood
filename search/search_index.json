{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Intro Think of Lightwood as Keras + Ludwig but for Pytorch, with two objectives: Make it so simple that you can build models with just a line of code. Make it so flexible that change and customize everything. Installing Lightwood pip3 install lightwood You would need python 3.5 or higher. Quick example Asume that you have a training file (sensor_data.csv) such as this one. sensor1 sensor2 sensor3 1 -1 -1 0 1 0 -1 -1 1 1 0 0 0 1 0 -1 1 -1 0 0 0 -1 -1 1 1 0 0 And you would like to learn to predict the values of sensor3 given the readings in sensor1 and sensor2 . Learn You can train a Predictor as follows: from lightwood import Predictor import pandas sensor3_predictor = Predictor ( output = [ 'sensor3' ]) sensor3_predictor . learn ( from_data = pandas . read_csv ( 'sensor_data.csv' )) Predict You can now given new readings from sensor1 and sensor2 predict what sensor3 will be. prediction = sensor3_predictor . predict ( when = { 'sensor1' : 1 , 'sensor2' : - 1 }) print ( prediction ) Of course that example was just the tip of the iceberg, please read about the main concepts of lightwood, the API and then jump into examples.","title":"Intro"},{"location":"#intro","text":"Think of Lightwood as Keras + Ludwig but for Pytorch, with two objectives: Make it so simple that you can build models with just a line of code. Make it so flexible that change and customize everything.","title":"Intro"},{"location":"#installing-lightwood","text":"pip3 install lightwood You would need python 3.5 or higher.","title":"Installing Lightwood"},{"location":"#quick-example","text":"Asume that you have a training file (sensor_data.csv) such as this one. sensor1 sensor2 sensor3 1 -1 -1 0 1 0 -1 -1 1 1 0 0 0 1 0 -1 1 -1 0 0 0 -1 -1 1 1 0 0 And you would like to learn to predict the values of sensor3 given the readings in sensor1 and sensor2 .","title":"Quick example"},{"location":"#learn","text":"You can train a Predictor as follows: from lightwood import Predictor import pandas sensor3_predictor = Predictor ( output = [ 'sensor3' ]) sensor3_predictor . learn ( from_data = pandas . read_csv ( 'sensor_data.csv' ))","title":"Learn"},{"location":"#predict","text":"You can now given new readings from sensor1 and sensor2 predict what sensor3 will be. prediction = sensor3_predictor . predict ( when = { 'sensor1' : 1 , 'sensor2' : - 1 }) print ( prediction ) Of course that example was just the tip of the iceberg, please read about the main concepts of lightwood, the API and then jump into examples.","title":"Predict"},{"location":"API/","text":"API Predictor Lightwood has one main class; the Predictor , which is what you train from your data, and what you get predictions from. from lightwood import Predictor Building Blocks The main concept is that ML models can be very modular, and each building block is something that you can thinker with. There are 3 main building blocks ( features, encoders, mixers ). Features : input_features : These are the columns in your dataset that you want to take as input for your predictor. output_features : These are the columns in your dataset that you want to learn how to predict. Encoders : These are tools to turn the data in your input or output features into vector/tensor representations and vice-versa. Mixers : How you mix the output of encoded features and also other mixers Constructor my_predictor = Predictor ( output = [] | config = { ... } | load_from_path =< file_path > ) It can take on of the following three arguments: load_from_path : If you have a saved predictor that you want to load, just give the path to the file output : A list with the column names you want to predict. ( Note: If you pass this argument, lightwood will simply try to guess the best config possible ) config : A dictionary, containing the configuration on how to glue all the building blocks. Predictror's config The config argument allows you to pass a dictionary that defines and gives you absolute control over how to build your predictive model. A config example goes as follows: from lightwood import COLUMN_DATA_TYPES , BUILTIN_MIXERS config = { 'input_features' : [ { 'name' : 'sensor1' , 'type' : COLUMN_DATA_TYPES . NUMERIC }, { 'name' : 'sensor2' , 'type' : COLUMN_DATA_TYPES . NUMERIC } ], 'output_features' : [ { 'name' : 'action_to_take' , 'type' : COLUMN_DATA_TYPES . CATEGORICAL } ], 'default_mixer' : { 'class' : BUILTIN_MIXERS . NnMixer } } Features Both input_features and output_features configs are simple dicts that have the following schema { 'name' : str , Optional ( 'type' ): any of COLUMN_DATA_TYPES , Optional ( 'encoder_class' ): object , Optional ( 'encoder_attrs' ): dict } name : is the name of the column as it is in the input data frame type : is the type od data contained. Where out of the box, supported COLUMN_DATA_TYPES are: NUMERIC = 'numeric' CATEGORICAL = 'categorical' DATETIME = 'datetime' IMAGE = 'image' TEXT = 'text' TIME_SERIES = 'time_series' If you specify the type, it will use the default encoder for that type or else you can specify the encoder you want to use. encoder_class : This is if you want to replace the default encoder with a different one, so you put the encoder class there encoder_attrs : These are the attributes that you want to setup on the encoder once the class its initialized Mixers","title":"API"},{"location":"API/#api","text":"","title":"API"},{"location":"API/#predictor","text":"Lightwood has one main class; the Predictor , which is what you train from your data, and what you get predictions from. from lightwood import Predictor","title":"Predictor"},{"location":"API/#building-blocks","text":"The main concept is that ML models can be very modular, and each building block is something that you can thinker with. There are 3 main building blocks ( features, encoders, mixers ). Features : input_features : These are the columns in your dataset that you want to take as input for your predictor. output_features : These are the columns in your dataset that you want to learn how to predict. Encoders : These are tools to turn the data in your input or output features into vector/tensor representations and vice-versa. Mixers : How you mix the output of encoded features and also other mixers","title":"Building Blocks"},{"location":"API/#constructor","text":"my_predictor = Predictor ( output = [] | config = { ... } | load_from_path =< file_path > ) It can take on of the following three arguments: load_from_path : If you have a saved predictor that you want to load, just give the path to the file output : A list with the column names you want to predict. ( Note: If you pass this argument, lightwood will simply try to guess the best config possible ) config : A dictionary, containing the configuration on how to glue all the building blocks.","title":"Constructor"},{"location":"API/#predictrors-config","text":"The config argument allows you to pass a dictionary that defines and gives you absolute control over how to build your predictive model. A config example goes as follows: from lightwood import COLUMN_DATA_TYPES , BUILTIN_MIXERS config = { 'input_features' : [ { 'name' : 'sensor1' , 'type' : COLUMN_DATA_TYPES . NUMERIC }, { 'name' : 'sensor2' , 'type' : COLUMN_DATA_TYPES . NUMERIC } ], 'output_features' : [ { 'name' : 'action_to_take' , 'type' : COLUMN_DATA_TYPES . CATEGORICAL } ], 'default_mixer' : { 'class' : BUILTIN_MIXERS . NnMixer } }","title":"Predictror's config"},{"location":"API/#features","text":"Both input_features and output_features configs are simple dicts that have the following schema { 'name' : str , Optional ( 'type' ): any of COLUMN_DATA_TYPES , Optional ( 'encoder_class' ): object , Optional ( 'encoder_attrs' ): dict } name : is the name of the column as it is in the input data frame type : is the type od data contained. Where out of the box, supported COLUMN_DATA_TYPES are: NUMERIC = 'numeric' CATEGORICAL = 'categorical' DATETIME = 'datetime' IMAGE = 'image' TEXT = 'text' TIME_SERIES = 'time_series' If you specify the type, it will use the default encoder for that type or else you can specify the encoder you want to use. encoder_class : This is if you want to replace the default encoder with a different one, so you put the encoder class there encoder_attrs : These are the attributes that you want to setup on the encoder once the class its initialized","title":"Features"},{"location":"API/#mixers","text":"","title":"Mixers"}]}